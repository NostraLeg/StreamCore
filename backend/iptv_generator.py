import secrets
import string
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from urllib.parse import quote
import base64
import hashlib
from models import IPTVChannel, Playlist, AccessCode
import aiohttp
import asyncio

class IPTVGenerator:
    def __init__(self, base_url: str):
        self.base_url = base_url
        
    def generate_access_code(self, length: int = 12) -> str:
        """Generate secure access code"""
        alphabet = string.ascii_uppercase + string.digits
        return ''.join(secrets.choice(alphabet) for _ in range(length))
    
    def generate_secure_token(self, user_id: str, playlist_id: str, expires_hours: int = 24) -> str:
        """Generate secure streaming token"""
        payload = f"{user_id}:{playlist_id}:{datetime.utcnow().isoformat()}:{expires_hours}"
        encoded = base64.b64encode(payload.encode()).decode()
        signature = hashlib.sha256(f"{encoded}:SECRET_STREAM_KEY".encode()).hexdigest()[:16]
        return f"{encoded}.{signature}"
    
    def encrypt_stream_url(self, original_url: str, token: str) -> str:
        """Encrypt and proxy stream URL"""
        encoded_url = base64.b64encode(original_url.encode()).decode()
        return f"{self.base_url}/api/stream/proxy/{token}/{quote(encoded_url)}"
    
    async def generate_m3u8_playlist(self, playlist: Playlist, channels: List[IPTVChannel], 
                                   user_id: str, secure: bool = True) -> str:
        """Generate M3U8 playlist file"""
        m3u8_content = "#EXTM3U\n"
        m3u8_content += "#EXT-X-VERSION:3\n"
        m3u8_content += f"#PLAYLIST:Generated by SecureIPTV - {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        
        for channel in channels:
            if channel.id in playlist.channels:
                # Generate secure token for this channel
                token = self.generate_secure_token(user_id, channel.id) if secure else ""
                
                # Encrypt URL if security enabled
                stream_url = self.encrypt_stream_url(channel.url, token) if secure else channel.url
                
                # Add channel info
                m3u8_content += f"#EXTINF:-1 "
                m3u8_content += f'tvg-id="{channel.id}" '
                m3u8_content += f'tvg-name="{channel.name}" '
                m3u8_content += f'tvg-logo="{channel.logo_url or ""}" '
                m3u8_content += f'group-title="{channel.category.value.title()}"'
                
                if channel.country:
                    m3u8_content += f' tvg-country="{channel.country}"'
                if channel.language:
                    m3u8_content += f' tvg-language="{channel.language}"'
                
                m3u8_content += f",{channel.name}\n"
                m3u8_content += f"{stream_url}\n\n"
        
        return m3u8_content
    
    async def generate_json_playlist(self, playlist: Playlist, channels: List[IPTVChannel], 
                                   user_id: str) -> Dict[str, Any]:
        """Generate JSON format playlist for API consumption"""
        return {
            "playlist_info": {
                "id": playlist.id,
                "name": playlist.name,
                "description": playlist.description,
                "created_at": playlist.created_at.isoformat(),
                "total_channels": len([c for c in channels if c.id in playlist.channels])
            },
            "channels": [
                {
                    "id": channel.id,
                    "name": channel.name,
                    "url": self.encrypt_stream_url(
                        channel.url, 
                        self.generate_secure_token(user_id, channel.id)
                    ),
                    "logo": channel.logo_url,
                    "category": channel.category.value,
                    "country": channel.country,
                    "language": channel.language,
                    "quality": channel.quality
                }
                for channel in channels if channel.id in playlist.channels
            ]
        }
    
    async def validate_stream_url(self, url: str) -> Dict[str, Any]:
        """Validate if stream URL is accessible"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.head(url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                    return {
                        "valid": response.status == 200,
                        "status_code": response.status,
                        "content_type": response.headers.get("content-type", ""),
                        "content_length": response.headers.get("content-length", "0")
                    }
        except Exception as e:
            return {
                "valid": False,
                "error": str(e),
                "status_code": 0
            }
    
    def decode_stream_token(self, token: str) -> Optional[Dict[str, str]]:
        """Decode and validate stream token"""
        try:
            encoded_part, signature = token.split('.')
            payload = base64.b64decode(encoded_part).decode()
            
            # Verify signature
            expected_signature = hashlib.sha256(f"{encoded_part}:SECRET_STREAM_KEY".encode()).hexdigest()[:16]
            if signature != expected_signature:
                return None
            
            user_id, playlist_id, timestamp, expires_hours = payload.split(':')
            
            # Check expiry
            created_time = datetime.fromisoformat(timestamp)
            expiry_time = created_time + timedelta(hours=int(expires_hours))
            
            if datetime.utcnow() > expiry_time:
                return None
            
            return {
                "user_id": user_id,
                "playlist_id": playlist_id,
                "created_at": timestamp,
                "expires_hours": expires_hours
            }
        except Exception:
            return None
    
    async def create_bulk_channels(self, channels_data: List[Dict[str, Any]], user_id: str) -> List[IPTVChannel]:
        """Create multiple channels from bulk data"""
        created_channels = []
        
        for channel_data in channels_data:
            # Validate URL
            validation = await self.validate_stream_url(channel_data.get("url", ""))
            
            if validation.get("valid", False):
                channel = IPTVChannel(
                    name=channel_data.get("name", "Unknown Channel"),
                    url=channel_data["url"],
                    logo_url=channel_data.get("logo_url"),
                    category=channel_data.get("category", "general"),
                    country=channel_data.get("country"),
                    language=channel_data.get("language"),
                    quality=channel_data.get("quality", "HD"),
                    created_by=user_id
                )
                created_channels.append(channel)
        
        return created_channels

# Proxy Service for Stream URLs
class StreamProxy:
    def __init__(self):
        self.active_sessions = {}
    
    async def proxy_stream(self, token: str, encoded_url: str) -> bytes:
        """Proxy stream through our server"""
        # Decode and validate token
        generator = IPTVGenerator("")
        token_data = generator.decode_stream_token(token)
        
        if not token_data:
            raise Exception("Invalid or expired token")
        
        # Decode original URL
        try:
            original_url = base64.b64decode(encoded_url).decode()
        except Exception:
            raise Exception("Invalid URL encoding")
        
        # Proxy the stream
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(original_url) as response:
                    if response.status == 200:
                        return await response.read()
                    else:
                        raise Exception(f"Stream error: {response.status}")
        except Exception as e:
            raise Exception(f"Proxy error: {str(e)}")